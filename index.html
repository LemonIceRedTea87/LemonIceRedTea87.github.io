<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>合成澳門地標</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 450px;
            height: 100%;
            background-color: #fef0cd;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
        }
        .score-box {
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 20px;
            border-radius: 30px;
            font-size: 24px;
            font-weight: bold;
            color: #d35400;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 2px solid #f39c12;
        }
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        #game-over h1 { font-size: 40px; color: #f1c40f; margin-bottom: 10px; }
        #game-over button {
            padding: 12px 40px;
            font-size: 20px;
            border-radius: 30px;
            background: #e74c3c;
            color: white;
            border: none;
            cursor: pointer;
            margin-top: 20px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui-layer">
        <div class="score-box">分數: <span id="score">0</span></div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="game-over">
        <h1>遊戲結束</h1>
        <p style="font-size: 20px;">得分: <span id="final-score">0</span></p>
        <button onclick="restartGame()">重新開始</button>
    </div>
</div>

<script>
    // 遊戲物件設定 - 對應你提供的五張圖片
    const ITEMS = [
        { level: 0, radius: 28, imgPath: '圖片_20260223233154_107_93.jpg', name: '燈塔' },
        { level: 1, radius: 42, imgPath: '圖片_20260223233155_108_93.jpg', name: '教堂' },
        { level: 2, radius: 65, imgPath: '圖片_20260223233157_111_93.jpg', name: '媽閣廟' },
        { level: 3, radius: 95, imgPath: '圖片_20260223233157_110_93.jpg', name: '旅遊塔' },
        { level: 4, radius: 135, imgPath: '圖片_20260223233156_109_93.jpg', name: '新葡京' }
    ];

    const loadedImages = {};
    ITEMS.forEach(item => {
        const img = new Image();
        img.src = item.imgPath;
        img.onload = () => { loadedImages[item.level] = img; };
    });

    const { Engine, Render, Runner, Bodies, Composite, Events, Body } = Matter;

    let engine, world, runner, currentBody = null, canDrop = true, score = 0, isGameOver = false;
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('game-container');

    function init() {
        const width = container.clientWidth;
        const height = container.clientHeight;
        canvas.width = width;
        canvas.height = height;

        engine = Engine.create();
        world = engine.world;
        
        // 牆壁
        const ground = Bodies.rectangle(width/2, height + 50, width, 100, { isStatic: true, friction: 0.5 });
        const leftWall = Bodies.rectangle(-50, height/2, 100, height, { isStatic: true });
        const rightWall = Bodies.rectangle(width + 50, height/2, 100, height, { isStatic: true });
        Composite.add(world, [ground, leftWall, rightWall]);

        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                const { bodyA, bodyB } = pair;
                if (bodyA.level !== undefined && bodyA.level === bodyB.level && !bodyA.isMerging && !bodyB.isMerging) {
                    if (bodyA.level < ITEMS.length - 1) {
                        bodyA.isMerging = bodyB.isMerging = true;
                        const newLevel = bodyA.level + 1;
                        const newPos = { x: (bodyA.position.x + bodyB.position.x)/2, y: (bodyA.position.y + bodyB.position.y)/2 };
                        
                        setTimeout(() => {
                            Composite.remove(world, [bodyA, bodyB]);
                            const nextItem = ITEMS[newLevel];
                            const newObj = Bodies.circle(newPos.x, newPos.y, nextItem.radius, { restitution: 0.3, friction: 0.5 });
                            newObj.level = newLevel;
                            Composite.add(world, newObj);
                            score += (newLevel + 1) * 5;
                            document.getElementById('score').innerText = score;
                        }, 50);
                    }
                }
            });
        });

        runner = Runner.create();
        Runner.run(runner, engine);
        spawnNext();
        loop();
    }

    function spawnNext() {
        if (isGameOver) return;
        const level = Math.random() > 0.7 ? 1 : 0;
        const item = ITEMS[level];
        currentBody = Bodies.circle(canvas.width / 2, 50, item.radius, { isStatic: true, isSensor: true });
        currentBody.level = level;
        Composite.add(world, currentBody);
        canDrop = true;
    }

    function loop() {
        if (isGameOver) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 警戒線
        ctx.beginPath();
        ctx.setLineDash([5, 5]);
        ctx.moveTo(0, 120);
        ctx.lineTo(canvas.width, 120);
        ctx.strokeStyle = '#e74c3c';
        ctx.stroke();
        ctx.setLineDash([]);

        const bodies = Composite.allBodies(world);
        bodies.forEach(body => {
            if (body.level === undefined) return;
            const item = ITEMS[body.level];
            const img = loadedImages[body.level];

            ctx.save();
            ctx.translate(body.position.x, body.position.y);
            ctx.rotate(body.angle);
            
            ctx.beginPath();
            ctx.arc(0, 0, item.radius, 0, Math.PI * 2);
            ctx.clip();

            if (img) {
                // 保持比例裁切繪製
                const scale = (item.radius * 2 * 0.9) / Math.max(img.width, img.height);
                const w = img.width * scale;
                const h = img.height * scale;
                ctx.drawImage(img, -w/2, -h/2, w, h);
            } else {
                ctx.fillStyle = '#ccc';
                ctx.fill();
            }
            
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#fff';
            ctx.stroke();
            ctx.restore();

            if (!body.isStatic && body.position.y < 120 && Math.abs(body.velocity.y) < 0.1) {
                endGame();
            }
        });

        requestAnimationFrame(loop);
    }

    function handleInput(e) {
        if (!canDrop || !currentBody) return;
        const x = (e.clientX || e.touches[0].clientX) - container.offsetLeft;
        const item = ITEMS[currentBody.level];
        const safeX = Math.max(item.radius, Math.min(x, canvas.width - item.radius));
        Body.setPosition(currentBody, { x: safeX, y: 50 });

        if (e.type === 'mouseup' || e.type === 'touchend') {
            canDrop = false;
            Body.setStatic(currentBody, false);
            currentBody.isSensor = false;
            currentBody = null;
            setTimeout(spawnNext, 1000);
        }
    }

    function endGame() {
        isGameOver = true;
        document.getElementById('final-score').innerText = score;
        document.getElementById('game-over').style.display = 'flex';
    }

    function restartGame() {
        location.reload();
    }

    container.addEventListener('mousemove', handleInput);
    container.addEventListener('mouseup', handleInput);
    container.addEventListener('touchstart', handleInput);
    container.addEventListener('touchmove', handleInput);
    container.addEventListener('touchend', handleInput);

    init();
</script>

</body>

</html>
