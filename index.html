<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>合成澳門地標 - Macau Merge</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f39c12;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 450px;
            height: 100%;
            background: #fef0cd;
            box-shadow: 0 0 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* 語言切換按鈕 */
        #lang-toggle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #d35400;
            color: #d35400;
            padding: 5px 12px;
            border-radius: 15px;
            font-weight: bold;
            cursor: pointer;
            z-index: 80;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        /* 遊戲中 UI */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            display: none;
            z-index: 10;
        }
        .score-box {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 24px;
            font-weight: 900;
            color: #d35400;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            border: 2px solid #f39c12;
            line-height: 1.2;
        }
        .best-score-text {
            font-size: 14px;
            color: #7f8c8d;
            font-weight: bold;
        }
        /* 開始頁面 */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(254, 240, 205, 0.3);
            backdrop-filter: blur(2px);
            z-index: 60;
        }
        #start-screen h1 {
            font-size: 50px;
            color: #fff;
            text-shadow: 3px 3px 10px rgba(0,0,0,0.8), -1px -1px 0 #d35400, 1px -1px 0 #d35400, -1px 1px 0 #d35400, 1px 1px 0 #d35400;
            margin-bottom: 40px;
            text-align: center;
            line-height: 1.1;
            pointer-events: none;
        }
        .btn {
            padding: 15px 50px;
            font-size: 24px;
            border-radius: 50px;
            background: #e74c3c;
            color: #fff;
            border: 4px solid #fff;
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            font-weight: bold;
            pointer-events: auto;
            z-index: 70;
            text-align: center;
        }
        .btn:active { transform: scale(0.95); }
        /* 結算頁面 */
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        #game-over h1 { font-size: 48px; color: #f1c40f; margin-bottom: 10px; }
        .result-text { font-size: 24px; margin: 5px 0; }
        .highlight { color: #f1c40f; font-weight: bold; font-size: 32px; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="score-box">
            <span id="label-score">得分</span>: <span id="score">0</span><br>
            <span class="best-score-text"><span id="label-best">最高</span>: <span id="ui-best-score">0</span></span>
        </div>
    </div>

    <div id="start-screen">
        <h1 id="main-title">合成<br>澳門地標</h1>
        <div class="btn" id="start-btn" onclick="startGame()">開始遊戲</div>
        <div id="lang-toggle" onclick="toggleLanguage()">English</div>
    </div>

    <div id="game-over">
        <h1 id="label-over">遊戲結束</h1>
        <p class="result-text"><span id="label-final">本次得分</span>: <span id="final-score" class="highlight">0</span></p>
        <p class="result-text" style="font-size: 18px; color: #ccc;"><span id="label-history">歷史最高</span>: <span id="final-best-score">0</span></p>
        <div class="btn" id="replay-btn" style="margin-top: 30px;" onclick="startGame()">再玩一次</div>
    </div>
</div>

<script>
    const ITEMS = [
        { level: 0, radius: 32, imgPath: '圖片_20260223233154_107_93.jpg', names: { cn: '燈塔', en: 'Lighthouse' }, bgColor: '#000000', borderColor: '#ffffff' },
        { level: 1, radius: 48, imgPath: '圖片_20260223233155_108_93.jpg', names: { cn: '教堂', en: 'Church' }, bgColor: '#000000', borderColor: '#ffffff' },
        { level: 2, radius: 75, imgPath: '圖片_20260223233157_111_93.jpg', names: { cn: '媽閣廟', en: 'A-Ma Temple' }, bgColor: '#000000', borderColor: '#ffffff' },
        { level: 3, radius: 110, imgPath: '圖片_20260223233157_110_93.jpg', names: { cn: '旅遊塔', en: 'Macau Tower' }, bgColor: '#000000', borderColor: '#ffffff' },
        { level: 4, radius: 150, imgPath: '圖片_20260223233156_109_93.jpg', names: { cn: '新葡京', en: 'Grand Lisboa' }, bgColor: '#000000', borderColor: '#ffffff' }
    ];

    const TEXTS = {
        cn: {
            title: '合成<br>澳門地標',
            start: '開始遊戲',
            score: '得分',
            best: '最高',
            over: '遊戲結束',
            final: '本次得分',
            history: '歷史最高',
            replay: '再玩一次',
            lang: 'English'
        },
        en: {
            title: 'Macau<br>Merge',
            start: 'Start Game',
            score: 'Score',
            best: 'Best',
            over: 'Game Over',
            final: 'Final Score',
            history: 'Record High',
            replay: 'Play Again',
            lang: '中文'
        }
    };

    let currentLang = localStorage.getItem('macauLang') || 'cn';
    const loadedImages = {};
    
    ITEMS.forEach(item => {
        const img = new Image();
        img.src = item.imgPath;
        img.onload = () => { loadedImages[item.level] = img; };
    });

    const { Engine, Runner, Bodies, Composite, Events, Body } = Matter;

    let engine, world, runner;
    let currentBody = null;
    let canDrop = false;
    let score = 0;
    let gameState = 'start'; 
    let bestScore = localStorage.getItem('macauBestScore') || 0;
    let demoInterval = null;

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('game-container');
    const dpr = window.devicePixelRatio || 2;

    function updateLanguageUI() {
        const t = TEXTS[currentLang];
        document.getElementById('main-title').innerHTML = t.title;
        document.getElementById('start-btn').innerText = t.start;
        document.getElementById('label-score').innerText = t.score;
        document.getElementById('label-best').innerText = t.best;
        document.getElementById('label-over').innerText = t.over;
        document.getElementById('label-final').innerText = t.final;
        document.getElementById('label-history').innerText = t.history;
        document.getElementById('replay-btn').innerText = t.replay;
        document.getElementById('lang-toggle').innerText = t.lang;
    }

    function toggleLanguage() {
        currentLang = currentLang === 'cn' ? 'en' : 'cn';
        localStorage.setItem('macauLang', currentLang);
        updateLanguageUI();
    }

    function init() {
        const width = container.clientWidth;
        const height = container.clientHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';

        engine = Engine.create();
        world = engine.world;
        
        const ground = Bodies.rectangle(width/2, height + 50, width * 2, 100, { isStatic: true, friction: 0.8 });
        const leftWall = Bodies.rectangle(-50, height/2, 100, height, { isStatic: true, friction: 0.1 });
        const rightWall = Bodies.rectangle(width + 50, height/2, 100, height, { isStatic: true, friction: 0.1 });
        Composite.add(world, [ground, leftWall, rightWall]);

        Events.on(engine, 'collisionStart', (event) => {
            if (gameState !== 'playing') return; 
            event.pairs.forEach(pair => {
                const { bodyA, bodyB } = pair;
                if (bodyA.level !== undefined && bodyA.level === bodyB.level && !bodyA.isMerging && !bodyB.isMerging) {
                    if (bodyA.level < ITEMS.length - 1) {
                        bodyA.isMerging = bodyB.isMerging = true;
                        const newLevel = bodyA.level + 1;
                        const newPos = { x: (bodyA.position.x + bodyB.position.x)/2, y: (bodyA.position.y + bodyB.position.y)/2 };
                        
                        setTimeout(() => {
                            Composite.remove(world, [bodyA, bodyB]);
                            const nextItem = ITEMS[newLevel];
                            const newObj = Bodies.circle(newPos.x, newPos.y, nextItem.radius, { restitution: 0.3, friction: 0.5 });
                            newObj.level = newLevel;
                            Composite.add(world, newObj);
                            score += (newLevel + 1) * 20;
                            document.getElementById('score').innerText = score;
                        }, 20);
                    }
                }
            });
        });

        runner = Runner.create();
        Runner.run(runner, engine);
        
        updateLanguageUI();
        loop();
        startDemoBackground();
    }

    function startDemoBackground() {
        demoInterval = setInterval(() => {
            if (gameState === 'start') {
                const bodies = Composite.allBodies(world).filter(b => !b.isStatic);
                const isFull = bodies.some(b => b.position.y < 100);
                if (!isFull && bodies.length < 50) {
                    const level = Math.floor(Math.random() * ITEMS.length);
                    const item = ITEMS[level];
                    const randomX = Math.random() * (container.clientWidth - item.radius * 2) + item.radius;
                    const demoBody = Bodies.circle(randomX, -item.radius * 2, item.radius, { 
                        restitution: 0.4, 
                        friction: 0.5,
                        angle: Math.random() * Math.PI,
                        torque: (Math.random() - 0.5) * 0.1 
                    });
                    demoBody.level = level;
                    Composite.add(world, demoBody);
                }
            }
        }, 150);
    }

    function startGame() {
        if (demoInterval) clearInterval(demoInterval);
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('game-over').style.display = 'none';
        document.getElementById('ui-layer').style.display = 'block';
        const bodies = Composite.allBodies(world);
        bodies.forEach(body => { if (!body.isStatic) Composite.remove(world, body); });
        gameState = 'playing';
        score = 0;
        document.getElementById('score').innerText = score;
        document.getElementById('ui-best-score').innerText = bestScore;
        spawnNext();
    }

    function spawnNext() {
        if (gameState !== 'playing') return;
        const level = Math.random() > 0.85 ? 1 : 0;
        const item = ITEMS[level];
        currentBody = Bodies.circle(container.clientWidth / 2, 70, item.radius, { 
            isStatic: true, 
            isSensor: true,
            label: 'preview' 
        });
        currentBody.level = level;
        Composite.add(world, currentBody);
        canDrop = true;
    }

    function loop() {
        requestAnimationFrame(loop);
        const width = container.clientWidth;
        const height = container.clientHeight;
        ctx.clearRect(0, 0, width, height);

        if (gameState === 'playing') {
            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.moveTo(0, 150);
            ctx.lineTo(width, 150);
            ctx.strokeStyle = 'rgba(211, 84, 0, 0.4)';
            ctx.stroke();
            ctx.setLineDash([]);
        }

        const bodies = Composite.allBodies(world);
        bodies.forEach(body => {
            if (body.level === undefined) return;
            const item = ITEMS[body.level];
            const img = loadedImages[body.level];

            ctx.save();
            ctx.translate(body.position.x, body.position.y);
            ctx.rotate(body.angle);
            
            ctx.beginPath();
            ctx.arc(0, 0, item.radius, 0, Math.PI * 2);
            ctx.fillStyle = item.bgColor;
            ctx.fill();
            
            ctx.save();
            ctx.beginPath();
            ctx.arc(0, 0, item.radius - 2, 0, Math.PI * 2);
            ctx.clip();
            if (img) {
                const scale = (item.radius * 2 * 0.92) / Math.max(img.width, img.height);
                const w = img.width * scale;
                const h = img.height * scale;
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(img, -w/2, -h/2, w, h);
            }
            ctx.restore();

            ctx.beginPath();
            ctx.arc(0, 0, item.radius, 0, Math.PI * 2);
            ctx.lineWidth = 2;
            ctx.strokeStyle = item.borderColor;
            ctx.stroke();

            const gradient = ctx.createRadialGradient(-item.radius/3, -item.radius/3, 0, 0, 0, item.radius);
            gradient.addColorStop(0, 'rgba(255,255,255,0.25)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.restore();

            if (gameState === 'playing' && !body.isStatic && body.position.y < 150 && Math.abs(body.velocity.y) < 0.05) {
                endGame();
            }
        });
    }

    function handleMove(e) {
        if (gameState !== 'playing' || !currentBody || !canDrop) return;
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        if (clientX === undefined) return;
        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const item = ITEMS[currentBody.level];
        const safeX = Math.max(item.radius, Math.min(x, container.clientWidth - item.radius));
        Body.setPosition(currentBody, { x: safeX, y: 70 });
    }

    function handleEnd(e) {
        if (gameState !== 'playing' || !currentBody || !canDrop) return;
        canDrop = false;
        Body.setStatic(currentBody, false);
        currentBody.isSensor = false;
        currentBody = null;
        setTimeout(spawnNext, 800);
    }

    function endGame() {
        if (gameState === 'gameover') return;
        gameState = 'gameover';
        if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('macauBestScore', bestScore);
        }
        document.getElementById('final-score').innerText = score;
        document.getElementById('final-best-score').innerText = bestScore;
        document.getElementById('game-over').style.display = 'flex';
    }

    container.addEventListener('mousedown', (e) => { if(gameState === 'playing') { canDrop = true; handleMove(e); } });
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleEnd);
    container.addEventListener('touchstart', (e) => { 
        if(gameState === 'playing') { e.preventDefault(); canDrop = true; handleMove(e); }
    }, {passive: false});
    container.addEventListener('touchmove', (e) => { if(gameState === 'playing') { e.preventDefault(); handleMove(e); } }, {passive: false});
    window.addEventListener('touchend', handleEnd);

    window.onload = init;
</script>

</body>
</html>
